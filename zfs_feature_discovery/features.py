import asyncio
import logging
from pathlib import Path
from typing import AsyncContextManager, AsyncIterable, Mapping, cast
import aiofiles

import aiofiles.os
from aiofiles.tempfile import NamedTemporaryFile

from zfs_feature_discovery.zfs_props import ZfsProperty
from zfs_feature_discovery.zpool import ZpoolManager


log = logging.getLogger(__name__)


class FeatureManager(AsyncContextManager):
    zpools: dict[str, ZpoolManager]

    def __init__(
        self,
        *,
        feature_dir: Path,
        zpool_props: frozenset[str],
        zfs_dataset_props: frozenset[str],
        label_namespace: str,
        feature_file_prefix: str = "zfs",
        zpool_label_format: str = "zpool/{pool_name}.{property_name}",
        zfs_dataset_label_format: str = "zfs-dataset/{dataset_name}.{property_name}",
    ) -> None:
        self.feature_dir = feature_dir
        self.feature_file_prefix = feature_file_prefix
        self.label_namespace = label_namespace
        self.zpool_props = zpool_props
        self.zfs_dataset_props = zfs_dataset_props
        self.zpool_label_format = zpool_label_format
        self.zfs_dataset_label_format = zfs_dataset_label_format

        self._zpools = {}

    def register_zpool(self, zpool: ZpoolManager) -> None:
        self._zpools[zpool.pool_name] = zpool

    async def write_feature_file(self, name: str, content: AsyncIterable[str]) -> None:
        full_name = f"{self.feature_file_prefix}-{name}"
        full_name = name.replace("/", "_")
        full_path = self.feature_dir / full_name

        # Make sure to use a name starting with dot and rename atomically, as documented
        # by node-feature-discovery
        async with NamedTemporaryFile(
            dir=full_path.parent, prefix=".tmp", delete=False
        ) as tmp_file:
            tmp_fname = cast(str, tmp_file.name)
            log.debug(f"Temporary feature file {tmp_fname}")

            try:
                async for chunk in content:
                    await tmp_file.write(chunk.encode())
                await tmp_file.flush()

                await aiofiles.os.rename(tmp_fname, full_path)
                log.info(f"Wrote feature file {full_path}")
            except Exception:
                log.exception(f"Failed writing feature file {full_path}")
            finally:
                try:
                    await aiofiles.os.unlink(tmp_fname)
                except OSError:
                    pass

    async def write_zpool_features(self, zpool: ZpoolManager) -> None:
        # We always write all the features; better an empty value than missing label
        system_props = await zpool.get_properties()
        all_props = {k: system_props.get(k) for k in self.zpool_props}

        async def gen_content():
            yield "# Generated by zfs-feature-discovery\n"

            ns = self.label_namespace
            for prop_name, prop_value in all_props.items():
                label = self.zpool_label_format.format(
                    pool_name=zpool.pool_name,
                    property_name=prop_name,
                )
                value = prop_value.value if prop_value else ""

                yield f"{ns}/{label}={value}\n"

        await self.write_feature_file(f"zpool-{zpool.pool_name}", gen_content())

    async def write_zfs_dataset_features(
        self, zpool: ZpoolManager, dataset: str, props: Mapping[str, ZfsProperty]
    ) -> None:
        # We always write all the features; better an empty value than missing label
        system_props = props
        all_props = {k: system_props.get(k) for k in self.zfs_dataset_props}

        async def gen_content():
            yield "# Generated by zfs-feature-discovery\n"

            ns = self.label_namespace
            for prop_name, prop_value in all_props.items():
                label = self.zfs_dataset_label_format.format(
                    dataset_name=dataset,
                    property_name=prop_name,
                )
                value = prop_value.value if prop_value else ""

                yield f"{ns}/{label}={value}\n"

        await self.write_feature_file(f"zfs-{zpool.pool_name}-{dataset}", gen_content())

    async def refresh_zpool(self, zpool: ZpoolManager) -> None:
        log.info(f"Refreshing features for zpool {zpool.pool_name}")
        await self.write_zpool_features(zpool)

    async def refresh_zpools(self) -> None:
        # make a copy to avoid any concurrency surprises
        zpools = self._zpools.copy()

        await asyncio.gather(*(self.refresh_zpool(zpool) for zpool in zpools.values()))

    async def refresh_zpool_datasets(self, zpool: ZpoolManager) -> None:
        async for ds, props in zpool.dataset_properties():
            log.info(f"Refreshing features for dataset {zpool.pool_name}/{ds}")
            await self.write_zfs_dataset_features(zpool, ds, props)

    async def __aenter__(self):
        return self

    async def __aexit__(self, *_) -> bool:
        return False
